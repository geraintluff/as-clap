"use strict"
const fs = require('fs'), resolvePath = require('path').resolve;

const clapPrefix = __dirname + "/clap/include/clap/";
try {
	fs.accessSync(clapPrefix);
} catch (e) {
	require('child_process').execSync(`git clone https://github.com/free-audio/clap.git ${__dirname}/clap`);
}

let asCode = `/* Generated by \`dev/translate-clap-structs.js\` - do not edit by hand */\n`;

let clapConstants = {
	CLAP_NAME_SIZE: 256,
	CLAP_PATH_SIZE: 1024,
	CLAP_REMOTE_CONTROLS_COUNT: 8
};

let knownTypes = {
	bool: 'bool',
	char: 'i8',
	
	int8_t: 'i8',
	int16_t: 'i16',
	int32_t: 'i32',
	int64_t: 'i64',

	uint8_t: 'u8',
	uint16_t: 'u16',
	uint32_t: 'u32',
	uint64_t: 'u64',
	
	float: 'f32',
	double: 'f64'
};
let skipTranslation = {
	clap_xwnd: true,
	clap_window: true,
};
for (let name in skipTranslation) {
	knownTypes[name] = name;
}

let structFields = {};

let structCount = 0;
let fieldCount = 0;
let typedefCount = 0;
let constantCount = 0;

function addConstant(name, value, comment) {
	++constantCount;
	comment = (comment ? ' // ' + comment : '');
	asCode += `export const ${name} = ${value.trim()};${comment}\n`;
}

let includedFiles = {};

addDir("");
addDir("/factory");
addDir("/factory/draft");
addDir("/ext");
addDir("/ext/draft");

function addDir(path) {
	let files = fs.readdirSync(clapPrefix + path);
	files.forEach(file => {
		if (/\.h$/.test(file)) addFile(`${path}/${file}`);
	});
}

function addFile(path) {
	path = resolvePath(path);
	if (/^\/clap\/include\/clap\/private\//.test(path)) return;
	if (includedFiles[path]) return;
	includedFiles[path] = true;

	let code = fs.readFileSync(`${clapPrefix}${path}`, 'utf8');
	// remove comments
	code = code.replaceAll(/\s*\/\/[^\n]*/g, '');
	code = code.replaceAll(/\/\*(.|\r|\n)*\*\//g, '');
	for (let key in clapConstants) {
		code = code.split(key).join(clapConstants[key]);
	}

	// Process all `#include`d files first first
	code = code.replaceAll(/#include\s+("[^"]+")/g, (match, includePath) => {
		includePath = JSON.parse(includePath);
		if (/^private\//.test(includePath)) return "";
		addFile(path.replace(/[^\/]*$/, '') + includePath);
		return "";
	});
	
	asCode += `\n//---------- ${path.substr(1)}\n`;

	// simple `typedef`s
	code.replaceAll(/typedef\s+([^\{\};]+)\s+([a-zA-Z_][a-zA-Z0-9_]*);/g, (match, typeName, alias) => {
		if (skipTranslation[alias]) {
			asCode += `// skipped ${alias}\n`;
			return;
		}
		if (!knownTypes[typeName]) {
			console.error(match);
			throw Error("unknown type in `typedef`");
		}
		++typedefCount;
		asCode += `export type ${alias} = ${knownTypes[typeName]};\n`;
		knownTypes[alias] = alias;
	});

	// catch all `#define`d numbers
	code = code.replaceAll(/#define\s+CLAP_([A-Z_]+)\s*([0-9][^\n]*)/g, (_, name, value) => {
		addConstant(name, value);
		return "";
	});
	// and strings
	code = code.replaceAll(/#define\s+CLAP_([A-Z_]+)\s*("[^"]+")/g, (_, name, value) => {
		addConstant(name, value);
		return "";
	});
	// anything else that looks like a numerical constant
	code = code.replaceAll(/CLAP_([A-Z_]+)\s*=\s*([0-9][^;,\}\)]*)/g, (_, name, value) => {
		value = value.trim();
		if (value == "1LL << 31") value = "0x80000000";
		addConstant(name, value);
		return "";
	});
	// anything that looks like a string constant
	code = code.replaceAll(/const\s+char\s+CLAP_([A-Z_]+)\[\]\s*=\s*("[^"]+")/g, (_, name, value) => {
		value = JSON.parse(value);
		let bytes = Array.from(new TextEncoder('utf8').encode(value)).concat(0);
		let hex = bytes.map(c => '0x' + c.toString(16)).join(',');
		addConstant(name, `memory.data<u8>([${hex}])`, value);
		return "";
	});
	
	addStructs(code);
}

function addStructs(cpp) {
	let parts = cpp.split('\ntypedef struct ');
	parts.slice(1).forEach(cpp => {
		let name = cpp.split(' ', 1)[0];
		let body = cpp.substr(name.length + 2).split("} " + name + "_t;", 1)[0];
		if (skipTranslation[name]) {
			asCode += `// skipped ${name}\n`;
			return;
		}
		++structCount;
		
		asCode += `@unmanaged\nexport class ${name} {\n`;

		let structFieldsList = structFields[name] = [];
		function addField(name, type, comment, arrayCount) {
			if (comment.length) comment = ` // ${comment}`;
			let arrayCode = arrayCount ? `@array(${arrayCount}) ` : '';
			asCode += `	${arrayCode}_${name} : ${type};${comment}\n`;
			structFieldsList.push([name, type, comment]);
		}

		let fields = body.split(';').map(x => x.trim()).filter(x => x.length);
		fields.forEach(cpp => {
			++fieldCount;
			let match;
			if (match = cpp.match(/^(.*[^a-zA-Z_])([a-zA-Z_][a-zA-Z0-9_]*)(\[([0-9]+)\])?$/)) {
				let fName = match[2], fType = match[1];
				fType = fType.trim().replace(/\s+/g, ' ').trim();
				let arrayCount = parseInt(match[4], 10) || null;
				if (/\*(\s*const)?$/.test(fType)) {
					addField(fName, 'usize', fType, arrayCount);
				} else if (knownTypes[fType]) {
					addField(fName, knownTypes[fType], '', arrayCount);
				} else if (/^clap_[a-z0-9_]+_t$/.test(fType)) {
					if (arrayCount) {
						console.error(cpp);
						throw Error("inline CLAP field can't also be an array");
					}
					fType = fType.replace(/_t$/, '');
					let otherFields = structFields[fType];
					if (!otherFields) {
						console.error(cpp);
						throw Error("Unknown CLAP type for struct field in: " + name);
					}
					asCode += `	// ${fName}: ${fType}\n`
					otherFields.forEach(field => {
						let [name, type, comment] = field;
						addField(`${fName}_${name}`, type, comment);
					});
					asCode += `	@inline get _${fName}() : ${fType} {\n`
					let firstFieldName = `_${fName}_${otherFields[0][0]}`;
					asCode += `		return changetype<${fType}>(changetype<usize>(this) + offsetof<${name}>(${JSON.stringify(firstFieldName)}))\n`;
					asCode += `	}\n`;
				} else {
					console.error(cpp);
					throw Error("Unknown type for struct field in: " + name);
				}
				return;
			} else if (match = cpp.match(/^(.*)\s*\(CLAP_ABI \*([a-zA-Z_][a-zA-Z0-9_]*)\)\(([^\)]*)\)$/)) {
				let fReturn = match[1];
				let fName = match[2];
				let fArgs = match[3].replace(/(\s|\n)+/g, ' ').split(',').map(x => x.trim()).filter(x => x != 'void');
				addField(fName, 'usize', `(${fArgs}) -> ${fReturn}`);
			} else {
				console.error(cpp);
				throw Error("Couldn't parse struct field in " + name);
			}
		});
		asCode += `}\n`;
	});
}

fs.writeFileSync("../assembly/clap-core.ts", asCode);

console.log(`translated ${structCount} structs (with ${fieldCount} fields), ${typedefCount} typedefs and ${constantCount} constants`);
